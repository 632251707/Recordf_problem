目录结构

目录概览：

+-- appname
  |-- app              （应用目录）
  |-- assembly         （装配目录）
  |-- conf             （SOFA 相关配置存放目录）
  |-- webroot           (静态资源和 MVC 模块文件存放路径)
  |-- pom.xml          （总POM文件）
app 目录

项目工程的总目录，其中包含项目分层的 test、web、biz、core、common 五个子目录，对应 SOFA 标准项目分层结构中的五个层，
这些子目录下又分了子目录，其结构也与分层结构图中的模块是一一对应。如果是 SOFA CORE 项目的话，则没有web目录。
每个子层次下面又分为子层的子项目 pom.xml 都继承自根目录的 pom.xml。

assembly 目录

assembly 目录的 pom.xml 里面定义了如何将一个工程打包成一个 SOFA .ace 发布包的过程。

conf 目录

conf 目录下存放了应用的各种配置文件，包括 sofa-config.properties，log4j.xml，java_opts，如果是 Web 应用，还包括 nginx 的配置文件。

应用工程结构

SOFA 工程项目结构图如下：

image

如图所示，SOFA 项目一共分成五层，分别是 test（测试层）、web（展现层）、biz（应用层）、core（核心领域层）、common（基础层），
除了测试层外，每个层中都按业务或功能再做了模块上的划分。这样一个经典的五层结构，很好的划分了应用系统的各个模块，结构清晰，职责明确。
一个完整的 SOFA 应用应该包含这五层，对于一些核心系统可以去掉展现层。图中的箭头表示模块之间的依赖关系，依赖具有传递性，假设 A 依赖 B ，
且 B 依赖 C ，则有 A 依赖 C 。下面详细介绍各层的功能、依赖关系和命名规范。

test层（测试层）

该层是 SOFA 项目中测试模块，提供了单元测试的基类，供开发人员继承或扩展。由于要对所有模块进行测试，因此该层位于 SOFA 系统最顶端，
可谓高瞻远瞩俯视群雄，它通过直接和间接依赖，可以访问到每个模块的代码，也即所有模块对测试层都是可见的。


web层（展现层）

web层是应用的视图展现层，SOFA MVC 专门为其提供了强大的 MVC 框架，该层是可选的，如果只开发纯业务的核心系统，可以去掉这一层，
需要结合 Web 层的项目可以查阅 SOFA MVC 的相关文档。

web-home 是 Web 层中的公用 Web 模块，它包含了运行视图层需要的所有公共组件的配置，是 SOFA MVC 能正常运行的基础。
该模块中可以放一些全局的处理逻辑，比如首页访问请求出炉、全局错误处理等。web-prod1、web-prod2 等是可选的 Web 模块，
用户根据实际应用的需要创建，用于处理不同模块的页面请求，它们之间是同级的，不存在互相依赖，在开发中也不要手动建立 Web 层各模块间的依赖，
这样不但会造成业务逻辑的混乱，也可能会形成循环依赖，所有公共的页面处理逻辑都应该放到 web-home 里。所有 Web 模块都依赖 web-home ，
且通过它间接依赖 biz、core 和 common 层。

biz层（业务应用层）

一般情况下，当业务逻辑没有复杂到使用核心领域层时，Biz 层相当于传统分层架构中的业务逻辑层：可以直接设计在 DAL 层之上，
调用 DAL 提供的数据访问服务，使用 DAL 层的 DO 作为数据传输对象，在此层实现所有业务逻辑，向展现层暴露业务服务接口。当引入了领域层时，Biz 层相当于领域驱动设计中的应用层：位于领域层之上，调用的是领域服务，使用的是领域模型，自己则专注于具体应用所需要的逻辑处理，而不包含核心业务规则，更多的是给领域层需要协作的各个领域服务协调任务、委派工作。

Biz 层的模块划分与 web 对应，公用的应用逻辑封装在 biz-shared 模块中，与 web-home 对应。prod1、prod2 等分别与 Web
层的相应模块一一对应，包含了对应模块的业务逻辑，它们之间不存在互相依赖，原因与 Web 层的相同。

biz-service-impl 模块中封装了对外发布的服务接口的具体实现。提供给外部系统调用的服务分为两部分，接口定义放在 common 层的
common-service-facade 模块，外部系统只需定义对该 facade 模块的依赖便可以 stub 的形式使用接口定义；而接口的实现则放在 Biz 层的 biz-service-impl 模块。该模块的业务可能会引用 biz-shared、biz-prod1、biz-prod2 等模块中的服务，所以它可以依赖 Biz 层的所有模块，但自动生成的 SOFA 工程只配置了 biz-service-impl 对 biz-shared 和 common-service-facade 的依赖，对其它 Biz 模块的依赖需要手根据实际需要动添加。所有 Biz 层模块都依赖于 biz-shared ，且通过它间接依赖 core 层和 common 层。

命名规范：该层业务服务类以 Manager 结尾，包装的门面以 Facade 结尾。

core层（核心领域层）

在传统的分层设计中是不包含领域层的，而是直接在 DAL 层之上设计 Biz 业务逻辑层。而当业务发展到一定深度和成熟度、
甚至可以制定行业标准时，就有必要进行领域层的设计。当然，按照领域驱动设计的方式，在一开始就进行领域层的设计，
为以后的业务扩展提供支持，也是一种良好的设计方案。

Core 层分为两个模块，core-service 模块封装核心业务，提供核心领域服务；core-model 模块包含领域层各个模型对象。
core-service 模块被 Biz 层依赖，为其提供核心领域服务，又依赖同层的 core-model ，使用其定义的模型对象，起到承上启下的作用。

命名规范：领域服务的命名以 Service 结尾。

common层（基础结构层）

在 Common 层中包含了为系统提供基础服务的各个模块：

common-dal 模块相当于传统分层中的数据访问层，封装了对数据库的访问逻辑，向上暴露 DAO 服务；util 模块则提供了基础的公用的工具服务。

common-dal 模块位于依赖链的最底层，所有模块都会直接或间接的依赖它，使用其 DAO 服务，但由于暴露的 DAO 服务很多、粒度很细，
如果全部发布为模块化服务会增加额外的工作量，所以在其它模块可以通过 Spring-Parent 的方式来依赖 common-dal ，从而直接使用 DAL 层的 DAO 服务。

装配目录-Assembly

装配目录包含了一个定义了如何讲一个 SOFA 应用打包成一个 ace 的 pom.xml。

pom.xml

通过 pom.xml 定义了业务系统打包时的输出目录 ../target/${assembly.name}.ace，以及不同文件的打包规则。

比如来自业务系统的 Jar 包将会被复制到 ../target/${assembly.name}.ace/core 目录；业务系统依赖的系统 JARs 会被复制到 
../target/${assembly.name}.ace/lib 目录；
所有的配置文件会被复制到 ../target/${assembly.name}.ace/conf。其他规则请参考 pom.xml。

⚠️注意

在服务器上运行应用的时候，实际上是需要将 SOFA 应用先打包，再通过相应的脚本进行启动，所以当增加一个依赖的时候，
注意 在 assembly/pom.xml 也需要增加对应的依赖，
否则运行时可能会出现 ClassNotFound 的异常。
